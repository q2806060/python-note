1.进程间的通信
    1.常用通信方式：管道、消息队列、共享内存、信号量
    2.原因
        进程空间相对独立，资源无法直接获取，此时在不同的进程间需要进行信息传输

2.管道通信（Pipe）：通过multiprocessing封装的管道模型
    1.通信原理：在内存中开辟管道空间，生成管道操作的对象，进程间使用同一组管道进行读写实现通信
    2.注：多个进程必须获取到同一个管道对象（创建进程之前先创建好管道，子进程在复制空间时一起复制走）
    3.管道分类
        1.单向管道（半双工）：一端只负责放数据，另一端只取
        2.双向管道（全双工）：两端都可以存取数据
    4.常用方法
        1.conn1,conn2 = Pipe(duplex=True)
            功能：创建管道
            参数：duplex默认为True(双向),False(单向)
            返回值：返回2个管道流对象，表示管道两端
            双向：两个均可发送和接收
            单向：conn1只能接收，conn2只能发送
        2.conn.send(内容)
            功能：向管道发送数据
        3.conn.recv()
            功能：从管道获取数据
            注：当管道中没有数据时，会阻塞，关闭发送端，接收端会抛出EOFError异常
        4.conn.close()
            功能：关闭管道的一端（发送端/接收端）
    5.注意
        1.父进程调用Pipe开辟管道，得到两个文件描述符指向管道的两端
        2.父进程用Process类创建子进程，则子进程也有两个文件描述符指向同一个管道
        3.每个进程（父/子进程）都要关闭管道的其中一类
        4.管道使用环形队列实现的，数据从发送端流入，从读端流出
        5.一次recv()只能接收1个数据

3.消息队列(Queue)：先进先出
    1.原理：在内存中开辟了队列模型，用来存放消息，任何拥有队列对象的进程都可以从中取数据
    2.常用方法
        1.q = Queue(maxsize=0)
            功能：在内存中创建1个消息队列
            参数：maxsize 默认为0，表示无限制
                 maxsize=3，队列中最多存放的消息数量为3

        2.q.put(block=True)
            向消息队列中存放1条消息，当满的时候，会阻塞
            block:默认为True(阻塞)
            timeout:阻塞时间

        3.q.get(block=True)
            获取消息，每次只获取1条，当为空时，会阻塞
            block:默认为True(阻塞)
            timeout:阻塞时间

        4.q.full()
            判断队列是否为满，True/False

        5.q.qsize()
            查看当前队列中消息的数量

        6.q.empty()
            判断队列是否为空，True/False

        7.close()
            关闭消息队列

4.进程池中队列的使用
    1.使用multiprocessing中的Manager
    2.q = Manager().Queue()
    3.pool = Pool()
    4.pool.apply(func=?)
    5.pool.close()
    6.pool.join()

5.共享内存（Value）
    1.原理：在内存中开辟一个区域，对多进程可见，进程都可以写入或者读取内容
    2.常用方法：
        1.obj = Value(ctype, data)
            功能：开辟共享内存
            参数：
                ctype字符串，用来决定data数据的类型
                    'i' ---> int
                    'f' ---> float
                    'c' ---> 单个字符(bytes)
                data：初始化存入数据
        2.obj.value：属性，获取共享内存的值
    3.锁（Lock）
        1.from multiprocessing import Lock
        2.lock = Lock()     创建锁对象
        3.lock.acquire()    加锁
        4.lock.release()    释放锁

6.共享内存（Array）
    1.常用方法 
        obj = Array(ctype, 一组值)
        功能：创建共享内存
        参数：
            一组值：列表/字节串，共享内存中初始数据
            Array('i', [1, 2, 3, 4 ,5])
            Array('c', 6)   可存放6个c类型的数据

7.3种通信方式的区别
                管道            消息队列            共享内存 
    开辟空间     内存              内存                内存
    读写方式   两端读写          先进先出           覆盖之前内容
    效率        一般               一般                较高
    使用特点   父子进程          第三方库多         注意争夺内存资源

8.信号量（信号灯-Semaphore）
    1.原理：给定一个数量，对多个进程可见，所有进程都可以操作信号量，达到协同工作的目的
    2.常用方法
        1.sem = Semaphore(number)
            功能：创建一个信号量
            参数：初始化信号量
        2.sem.release()
            功能：增加一个信号量资源
        3.sem.acquire()
            功能：消耗一个信号量，当为0时会阻塞
        4.sem.get_value()
            功能：获取信号量资源数量
            







































