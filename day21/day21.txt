
异常：
    with 语句：
        with 表达式1 [as 变量1], 表达式2[as 变量2],...
            语句块
        作用：
            使用于对资源进行访问的场合，确保使用中不管是否发生异常，都会执行必须的'清理'操作，并释放资源，如：文件使用后自动关闭，线程中锁的自动获取和释放等
        说明：
            执行表达式，用as子句中的变量绑定生成的对象
            with与try-finally相似，并不会改变异常状态


资源管理器（环境管理器）：
    类内有__enter__方法和__exit__实例方法的类被称为环境管理器
    能够用with进行管理的对象必须是环境管理器
    __enter__将在进入with语句时被调用，并返回由as变量管理的实例对象
    __exit__将在离开with语句时被调用，且可以用参数来判断在离开with语句时是否有异常发生并作出相应的处理


运算符重载：
    让自定义的类生成的对象（实例）能够使用运算符进行操作
    作用：让自定义的类的实例像内建对象一样进行运算符运算，让程序简洁易读，对自定义对象将运算符赋予新的运算规则
    说明：运算符重载方法的参数个数的传参都是固定的含义，不能随便修改形参的个数

算数运算符重载：
          方法名                运算符和表达式            说  明 
    __add__(self, rhs)           self + rhs              加法
    __sub__(self, rhs)           self - rhs              减法
    __mul__(self, rhs)           self * rhs              乘法
    __truediv__(self, rhs)       self / rhs              除法
    __floordiv__(self, rhs)      self // rhs             地板除
    __mod__(self, rhs)           self % rhs            求余（取模）
    __pow__(self, rhs)           self ** rhs             幂运算

反向算数运算符的重载：
    当算数符的左侧为内建函数类型，右侧为自定义类型运行算数运算符运算时，会出现TypeErroe错误
    因无法修改内建类型的代码来实现运算符重载，此时需要使用反向运算符重载来完成

          方法名                运算符和表达式            说  明 
    __radd__(self, lhs)           lhs + self              加法
    __rsub__(self, lhs)           lhs - self              减法
    __rmul__(self, lhs)           lhs * self              乘法
    __rtruediv__(self, lhs)       lhs / self              除法
    __rfloordiv__(self, lhs)      lhs // self            地板除
    __rmod__(self, lhs)           lhs % self           求余（取模）
    __rpow__(self, lhs)           lhs ** self            幂运算



复合赋值算术运算符的重载：
    以复合赋值算数运算符 x += y 为例，此运算符会优先调用 x.__iadd__(y) 方法
    如果没有，会将复合赋值运算拆解为x = x + y, 然后再调用 x = x.__add__(y)方法
    如果不存在__add__方法，则会触发TypeError类型的错误
    其他的有相同规则

          方法名                运算符和表达式            说  明 
    __iadd__(self, rhs)           self + rhs              加法
    __isub__(self, rhs)           self - rhs              减法
    __imul__(self, rhs)           self * rhs              乘法
    __itruediv__(self, rhs)       self / rhs              除法
    __ifloordiv__(self, rhs)      self // rhs             地板除
    __imod__(self, rhs)           self % rhs            求余（取模）
    __ipow__(self, rhs)           self ** rhs             幂运算


比较运算符的重载：

          方法名                运算符和表达式           说  明 
    __lt__(self, rhs)           self < rhs              大于
    __le__(self, rhs)           self <= rhs           大于等于
    __gt__(self, rhs)           self > rhs              小于
    __ge__(self, rhs)           self >= rhs           小于等于
    __eq__(self, rhs)           self == rhs             等于
    __ne__(self, rhs)           self != rhs            不等于


位运算符重载：

          方法名                运算符和表达式           说  明 
    __and__(self, rhs)          self & rhs              位与
    __or__(self, rhs)           self | rhs              位或
    __xor__(self, rhs)          self ^ rhs             位异或
    __lshift__(self, rhs)       self << rhs             左移
    __rshift__(self, rhs)       self >> rhs             右移

反向位运算符重载：pass

复合位运算符重载：pass

一元运算符的重载：

        方法名                运算符和表达式           说  明 
    __neg__(self)               -self                 负号
    __pos__(self)               +self                 正号
    __invert__(self)            -self                 取反


in / not in 运算符的重载：

        方法名                运算符和表达式           
    __contians__(self)         e in self                


索引和切片运算符的重写：

        方法名                 运算符和表达式           说  明 
    __getitem__(self, i)       v = self[i]         索引/切片取值
    __setitem__(self, i, v)    self[i] = v         索引/切片赋值
    __delitem__(self, i)       del self[i]         删除索引/切片

slice 构造函数：
    用于创建一个slice切片对象，用来存储一个切片的起始值，终止值，步长信息
    格式：
        slice(start = None, stop = None, step = None)
    slice对象的属性：
        s.start 切片的起始值，默认为None
        s.stop 切片的终止值，默认为None
        s.step 切片的步长，默认为None


特性属性 @property
    实现其他语言拥有的getter 和 setter 功能
    作用：
        用来模拟一个属性
        通过 @property 装饰器可以对模拟属性












