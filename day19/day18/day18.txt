day17 回顾
面向对象
  特征:
    属性
      实例属性(实例变量)
    行为
      实例方法(method)

类
  class 类名(继承列表):
      ....

构造函数
  类名(实参列表)

实例方法:
  class 类名(继承列表):
      def 方法名(self, 形参列表):
          语句块
      def __init__(self, 形参列表):
          '''初始化方法,主要为该类创建的对象添加统一的属性'''
          语句块
      def __del__(self):
          '''析构方法, 在对象被销毁前才被调用'''
      
实例方法的调用语法:
  对象(实例).实例方法名(调用传参)
  类名.方法名(实例-->self, 调用传参)

实例变量(实例属性)
  对象(实例).实例变量名 = 表达式    # 创建,或修改实例变量
  v = 对象(实例).实例变量名        # 实例变量的取值操作
删除实例变量:
  del 语句 删除实例变量

预置的实例变量(实例属性)
  __dict__ 属性字典, 绑定的是字典,存储的是 属性--> 值

  __class__属性  绑定 创建此实例的类

isinstance(对象, 类或元组)
type(x)  返回对象的类




day18笔记
类变量(类属性)
  类变量是类的属性, 此属性属于类,不属于此类的实例 

  作用:
    通常用来存储该类创建的对象的共有属性
  说明:
    1. 类变量可以通过该类直接访问
    2. 类变量可以通过类的实例直接访问 
    3. 类变量可以通过此类的对象的__class__属性间接访问
  示例见:
    class_variable.py
    class_variable2.py
    class_variable3.py
       

类的文档字符串
  类内第一个没有赋值给任何变量的字符串为类的文档字符串
  类的文档字符串可以通过help函数查看
  类的文档字符串可以用 类的 __doc__属性访问

  示例:
    class Human:
       '地球上的主载者'
       pass
  >>> help(Human)

类的__slots__列表
  作用:
    限定一个类创建的实例只能有固定的属性(实例变量)
    不允许对象添加列表以外的实例属性(实例变量)
    防止用户因错写属性的名称而发生程序运行时错误
  说明:
    1. __slots__属性是一个列表,列表的值是字符串
    2. 含有__slots__属性的列表所创建的实例对象没有__dict__
       属性即此实例不用字典来存储对象的实例属性(实例变量)
  示例见:
    class_slots.py

类方法 @classmethod
  类方法是用于描述类的行为的方法,类方法属于类,不属于该类创建
  的对象

  说明:
    1. 类方法需要使用@classmethod装饰器定义
    2. 类方法至少有一个形参,第一个形参用于绑定类,约定写为'cls'
    3. 类和该类的实例都可以调用类方法
    4. 类方法不能访问此类创建的对象的实例属性
  示例见:
    classmethod.py


静态方法 staticmethod
  静态方法是定义在类的内部的函数,此函数的作用域是类的内部

  说明:
    1. 静态方法需要使用@staticmethod装饰器定义
    2. 静态方法与普通函数定义相同,不需要传入self实例参数和
      cls 类参数
    3. 静态方法只能凭借该类或该类创建的实例来调用
    4. 静态方法不能访问类变量和实例变量
  示例见:
    staticmethod.py


实例方法, 类方法, 静态方法, 函数
    实例方法能访问实例变量, 类变量 和全局变量
    类方法不能访问实例变量,能访问类变量和全局变量
    静态方法不能访问实例变量,类变量,但能访问全局变量
    函数,只能访问全局变量


继承 (inheritance) 和派生(derived)
  什么是继承/派生
    继承是从已有的类中派生出新的类,新类具有原类的属性和行为,
    并能扩展新的行为
    派生类就是从一个已有类中衍生出新类,在新的类上可以添加新
    的属性和行为
  为什么继承/派生
    继承的目的是延续旧类的功能
    派生的目地是在旧类的基础上添加新功能
  作用:
    用继承派生机制, 可以将一些共有功能加在基类中,实现代码共享
    在不改变基类的代码的基础上改变原有类的功能
  名词
    基类(base class)/超类(super class)/父类(father class)
    派生类(derived class) / 子类(child class)

单继承
  语法:
    class 类名(基类名):
        语句块 
  说明:
    单继承是指派生类由一个基类衍生出来的
  示例见:
    inherit.py 


继承说明:
  Python3 任何类都直接或间接的继承自object类
  object类是一切类的超类

类的 __base__ 属性
  __base__属性用来记录此类的基类(父类,超类)

Python3内类的继承关系:
  详见:
     >>> help(__builtins__)
  

思考:
  list 类里只有apend向末尾加一个元素的方法,但没有向列表头部
  添加元素的方法,试想能否为列表在不改变原有功能的基础上添加一
  个 insert_head(n) 方法在列表的头部添加新元素

    class MyList(list):
        def insert_head(self, n):
             ....  # 此自己偿试写代码

    myl = MyList(range(3, 6))
    print(myl)  # [3, 4, 5]
    myl.insert_head(2)
    print(myl)  # [2, 3, 4, 5]
    myl.append(6)
    print(myl)  # [2, 3, 4, 5, 6]





覆盖 override
  什么是覆盖,
    覆盖是指在有继承关系的类中,子类中实现了与基类同名的方法,
    在子类的实例调用该方法时,实际调用的是子类中的覆盖版本,这
    种现象叫覆盖
  作用:
    实现和父类同名,但功能不同的方法

  示例见:
    override.py

问题:
  当覆盖发生时,子类对象能否调用父类中的方法?

子类对象显式调用基类方法:
  基类名.方法名(实例, 实际调用参数....)


super 函数
  super(cls, obj)  返回绑定超类的实例(要求obj必须为cls类
            型的实例或cls子类的实例)
  super()     返回绑定超类的实例,等同于:
            super(__class__, 实例方法的第一个参数), 必须
            用在方法内调用
  作用:
    借助super() 返回的实例间接调有和父类的覆盖方法
  示例见:
    super.py

显式调用基类的初始化方法:
  当子类中实现了__init__方法时,基类的初始化方法并不会被调用
  此时需要显式调用才能完成对父类对象的初始化

  示例见:
    super_init.py
    mylist.py

用于类的函数:
  issubclass(cls, class_or_tuple)  判断一个类是否继承自
     class, 如果此类cls 是class 或tuple元组中一个类的派生
     子类,则返回True,否则返回False

  示例:
    issubclass(bool, int)   # True
    class A:
        pass
    class B(A):
        pass
    class C(B):
        pass
    issubclass(C, B)  # True
    issubclass(B, A)  # True
    issubclass(C, A)  # True




练习:
  1. 修改原学生信息管理程序, 将原来用字典存储学生信息,改为
    用对象存储学生信息
      建议 写一个student.py 内存来存放:
        class Student:
             .....
  2. 写一个Bicycle类,用run方法,调用时显示骑行的里程
    class Bicycle:
        def run(self, km):
            print("自行车骑行了", km, '公里')
    
    再写一个EBicycle(电动自行车), 在Bicycle类的基础上,添加电池
    电量volume属性,此类有两个方法:
      fill_charge(vol)  用来充电,vol为电量(度)
      run(km) 方法 每骑行 10km 消耗1度电,同时显示当前电量,当
      电量耗尽时则用脚蹬骑行(调用Bicyle的run方法 )
    class EBicycle(Bicycle):
         ....
        
    测试程序:
    b = EBicycle(5)  # 新买的电动车内有5度电
    b.run(10)  # 电动骑行了10km 还剩4度电
    b.run(100) # 电动骑行了40km 还剩0度电  自行车骑行了 60 公里
    b.fill_charge(10)  # 电动自行车充电10度
    b.run(50)  # 电动骑行了50km 还剩5度电
            



